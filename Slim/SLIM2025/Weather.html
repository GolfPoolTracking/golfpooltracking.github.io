<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>SLIM 2025 - WEATHER FORECAST</title>
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
</head>
<body class="bg-sky-50">
<div id="root"></div>

<script type="text/javascript">
const { useState, useEffect } = React;

function WeatherWidget() {
  const [forecast, setForecast] = useState([]);
  const [lastUpdate, setLastUpdate] = useState(null);
  const [error, setError] = useState(null);

  const days = [
    { date: '2025-09-04', label: 'Thursday 4 Sep', course: 'Portsalon', lat: 55.2, lon: -7.6 },
    { date: '2025-09-05', label: 'Friday 5 Sep', course: 'Old Tom Morris', lat: 55.25, lon: -7.9 },
    { date: '2025-09-06', label: 'Saturday 6 Sep', course: "St Patrick's", lat: 55.25, lon: -7.9 },
    { date: '2025-09-07', label: 'Sunday 7 Sep', course: 'Sandy Hills', lat: 55.25, lon: -7.9 }
  ];

  useEffect(() => {
    async function getForecast() {
      try {
        const results = [];
        for (const day of days) {
          const url = `https://api.open-meteo.com/v1/forecast?latitude=${day.lat}&longitude=${day.lon}` +
                      `&hourly=temperature_2m,precipitation,weathercode,windspeed_10m,winddirection_10m&current_weather=true&timezone=auto` +
                      `&start_date=${day.date}&end_date=${day.date}`;

          const res = await fetch(url);
          if (!res.ok) throw new Error("API error " + res.status);
          const data = await res.json();
          if (!data.hourly) throw new Error("No hourly data returned");

          const updatedTime = data.current_weather?.time || new Date().toISOString();

          const hours = data.hourly.time.map((t, i) => {
            const d = new Date(t);
            return {
              time: t,
              hour: d.getHours(),
              temp: data.hourly.temperature_2m[i],
              rain: data.hourly.precipitation[i],
              code: data.hourly.weathercode[i],
              windSpeed: data.hourly.windspeed_10m[i],
              windDir: data.hourly.winddirection_10m[i],
            };
          }).filter(h => h.hour >= 8 && h.hour <= 18);

          let summary = 'Sunny';
          const rainTotal = hours.reduce((sum,h)=>sum+h.rain,0);
          const cloudHours = hours.filter(h=>[1,2,3].includes(h.code)).length;
          if(rainTotal>0) summary = `Rain expected`;
          else if(cloudHours > hours.length/2) summary = 'Cloudy';

          results.push({ label: day.label, course: day.course, hours, summary, lastUpdate: updatedTime });
        }

        setForecast(results);
        setLastUpdate(results[0]?.lastUpdate || new Date().toISOString());
        setError(null);
      } catch(e) {
        console.error(e);
        setError(e.message);
      }
    }

    getForecast();
  }, []);

  function getIcon(code, rain) {
    if(rain>0) return "ðŸŒ§ï¸";
    if(code===0) return "ðŸŒ¤ï¸";
    if([1,2,3].includes(code)) return "â˜ï¸";
    return "ðŸŒ¤ï¸";
  }

  function getWindArrow(deg){
    const arrows = ["â†‘","â†—","â†’","â†˜","â†“","â†™","â†","â†–"];
    const idx = Math.round(deg/45)%8;
    return arrows[idx];
  }

  function formatHour(h) {
    if(h===12) return '12pm';
    if(h===0) return '12am';
    if(h>12) return (h-12)+'pm';
    return h+'am';
  }

  return React.createElement(
    "div",
    { className:"max-w-5xl w-full mx-auto p-4 rounded-xl shadow bg-white" },

    // Last update
    lastUpdate && React.createElement(
      "p",
      { className:"text-center text-xs mt-0 mb-4 text-gray-600" },
      "Last forecast update: "+ new Date(lastUpdate).toLocaleString()
    ),

    // Title
    React.createElement(
      "h2",
      { className:"text-2xl font-bold mb-2 text-center" },
      "SLIM 2025 - WEATHER FORECAST"
    ),

    // Error
    error && React.createElement(
      "p",
      { className:"text-red-600 text-center mb-4" },
      "Error: "+error
    ),

    // Forecast per day
    forecast.map(day =>
      React.createElement(
        "div",
        { key:day.label, className:"mb-6" },

        React.createElement(
          "h3",
          { className:"text-lg font-bold mb-1 p-2 bg-green-500 text-white rounded" },
          `${day.label} â€“ ${day.course}`
        ),

        React.createElement(
          "p",
          { className:"text-sm italic mb-2" },
          day.summary
        ),

        // Hourly tiles container: horizontal scroll on mobile
        React.createElement(
          "div",
          { className:"flex overflow-x-auto gap-3 py-2" },
          day.hours.map((hour, idx)=>{
            const bgColor = hour.rain>0 ? "bg-blue-200" : "bg-sky-100";
            return React.createElement(
              "div",
              { key:idx, className:`flex-shrink-0 flex flex-col items-center p-2 rounded-lg shadow ${bgColor} min-w-[60px]` },
              React.createElement("span",{className:"text-xs font-semibold"}, formatHour(hour.hour)),
              React.createElement("div",{className:"my-1 text-2xl"}, getIcon(hour.code,hour.rain)),
              React.createElement("span",{className:"text-sm"}, Math.round(hour.temp)+"Â°C"),
              React.createElement("span",{className:"text-xs text-blue-700"}, hour.rain>0 ? hour.rain.toFixed(1)+"mm" : "â€”"),
              React.createElement("span",{className:"text-xs mt-1"}, `${Math.round(hour.windSpeed)} km/h ${getWindArrow(hour.windDir)}`)
            );
          })
        )
      )
    )
  );
}

ReactDOM.createRoot(document.getElementById("root")).render(
  React.createElement(WeatherWidget)
);
</script>
</body>
</html>
