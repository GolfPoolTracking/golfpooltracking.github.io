<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>SLIM 2025 - WEATHER FORECAST</title>
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
</head>
<body class="bg-sky-50">
<div id="root"></div>

<script type="text/javascript">
const { useState, useEffect } = React;

function WeatherWidget() {
  const [forecast, setForecast] = useState([]);
  const [lastUpdate, setLastUpdate] = useState(null);
  const [error, setError] = useState(null);

  const days = [
    { date: '2025-09-04', label: '4 Sep', course: 'Portsalon', lat: 55.2, lon: -7.6 },
    { date: '2025-09-05', label: '5 Sep', course: 'Old Tom Morris', lat: 55.25, lon: -7.9 },
    { date: '2025-09-06', label: '6 Sep', course: "St Patrick's", lat: 55.25, lon: -7.9 },
    { date: '2025-09-07', label: '7 Sep', course: 'Sandy Hills', lat: 55.25, lon: -7.9 }
  ];

  const summaryHoursMap = {
    '2025-09-04': { start: 13, end: 18 },
    '2025-09-05': { start: 12, end: 17 },
    '2025-09-06': { start: 13, end: 18 },
    '2025-09-07': { start: 8, end: 13 },
  };

  useEffect(() => {
    async function getForecast() {
      try {
        const results = [];
        for (const day of days) {
          const url = `https://api.open-meteo.com/v1/forecast?latitude=${day.lat}&longitude=${day.lon}` +
                      `&hourly=temperature_2m,precipitation,weathercode,windspeed_10m,winddirection_10m&current_weather=true&timezone=auto` +
                      `&start_date=${day.date}&end_date=${day.date}`;

          const res = await fetch(url);
          if (!res.ok) throw new Error("API error " + res.status);
          const data = await res.json();
          if (!data.hourly) throw new Error("No hourly data returned");

          const updatedTime = data.current_weather?.time || new Date().toISOString();

          const hours = data.hourly.time.map((t, i) => {
            const d = new Date(t);
            return {
              time: t,
              hour: d.getHours(),
              temp: data.hourly.temperature_2m[i],
              rain: data.hourly.precipitation[i],
              code: data.hourly.weathercode[i],
              windSpeed: data.hourly.windspeed_10m[i],
              windDir: data.hourly.winddirection_10m[i],
            };
          }).filter(h => h.hour >= 8 && h.hour <= 18);

          const summaryRange = summaryHoursMap[day.date];
          const summaryHours = hours.filter(h => h.hour >= summaryRange.start && h.hour <= summaryRange.end);

          let summary = 'Sunny';
          const rainTotal = summaryHours.reduce((sum,h)=>sum+h.rain,0);
          const cloudHours = summaryHours.filter(h=>[1,2,3].includes(h.code)).length;
          if(rainTotal>0) summary = `Rain expected`;
          else if(cloudHours > summaryHours.length/2) summary = 'Mostly cloudy';

          const avgWind = summaryHours.reduce((sum,h)=>sum+h.windSpeed,0)/summaryHours.length;
          const avgWindDirDeg = summaryHours.reduce((sum,h)=>sum+h.windDir,0)/summaryHours.length;
          const windArrows = ["N","NE","E","SE","S","SW","W","NW"];
          const windDirIndex = Math.round(avgWindDirDeg/45)%8;
          summary += `, Wind: ${Math.round(avgWind)} km/h ${windArrows[windDirIndex]}`;

          results.push({ label: day.label, course: day.course, hours, summary, lastUpdate: updatedTime, summaryRange });
        }

        setForecast(results);
        setLastUpdate(results[0]?.lastUpdate || new Date().toISOString());
        setError(null);
      } catch(e) {
        console.error(e);
        setError(e.message);
      }
    }

    getForecast();
  }, []);

  function getIcon(code, rain) {
    if(rain>0) return "ðŸŒ§ï¸";
    if(code===0) return "ðŸŒ¤ï¸";
    if([1,2,3].includes(code)) return "â˜ï¸";
    return "ðŸŒ¤ï¸";
  }

  function getWindArrow(deg){
    const arrows = ["â†‘","â†—","â†’","â†˜","â†“","â†™","â†","â†–"];
    const idx = Math.round(deg/45)%8;
    return arrows[idx];
  }

  function formatHour(h) {
    if(h===12) return '12pm';
    if(h===0) return '12am';
    if(h>12) return (h-12)+'pm';
    return h+'am';
  }

  return React.createElement(
    "div",
    { className:"max-w-5xl w-full mx-auto p-4 rounded-xl shadow bg-white" },

    lastUpdate && React.createElement(
      "p",
      { className:"text-center text-xs mt-0 mb-4 text-gray-600" },
      "Last forecast update: "+ new Date(lastUpdate).toLocaleString()
    ),

    React.createElement(
      "h2",
      { className:"text-2xl font-bold mb-2 text-center" },
      "SLIM 2025 - WEATHER FORECAST"
    ),

    React.createElement(
      "div",
      { className:"flex flex-wrap justify-center text-xs text-gray-700 mb-4 gap-4" },
      React.createElement("span", null, "ðŸŒ¤ï¸ Sunny / Clear"),
      React.createElement("span", null, "â˜ï¸ Cloudy"),
      React.createElement("span", null, "ðŸŒ§ï¸ Rain"),
      React.createElement("span", null, "Green border + darker bg â†’ key hours"),
      React.createElement("span", null, "Tile color â†’ default"),
      React.createElement("span", null, "Rain overlay â†’ darker"),
      React.createElement("span", null, "Wind arrow â†’ direction")
    ),

    error && React.createElement(
      "p",
      { className:"text-red-600 text-center mb-4" },
      "Error: "+error
    ),

    forecast.map(day =>
      React.createElement(
        "div",
        { key:day.label, className:"mb-6" },

        React.createElement(
          "h3",
          { className:"text-lg font-bold mb-1 p-2 bg-green-500 text-white rounded" },
          `${day.label} â€“ ${day.course}`
        ),

        // Key hours strip
        React.createElement(
          "div",
          { className:"flex mb-1 gap-1 overflow-x-auto" },
          Array.from({length:11}, (_,i)=>i+8).map(h=>{
            const isKey = h >= day.summaryRange.start && h <= day.summaryRange.end;
            return React.createElement("div", {
              key:h,
              className:`flex-shrink-0 w-5 h-2 rounded ${isKey ? "bg-green-500" : "bg-gray-300"}`
            });
          })
        ),

        React.createElement(
          "p",
          { className:"text-sm italic mb-2" },
          day.summary
        ),

        React.createElement(
          "div",
          { className:"flex overflow-x-auto gap-3 py-2" },
          day.hours.map((hour, idx)=>{
            const isKeyHour = hour.hour >= day.summaryRange.start && hour.hour <= day.summaryRange.end;
            let tileBg = hour.rain > 0 ? "bg-blue-200 brightness-90" : "bg-sky-100"; 
            const borderClass = isKeyHour ? "border-2 border-green-500 bg-sky-300" : ""; 
            return React.createElement(
              "div",
              { key:idx, className:`flex-shrink-0 flex flex-col items-center p-2 rounded-lg shadow min-w-[60px] ${tileBg} ${borderClass}` },
              React.createElement("span",{className:"text-xs font-semibold"}, formatHour(hour.hour)),
              React.createElement("div",{className:"my-1 text-2xl"}, getIcon(hour.code,hour.rain)),
              React.createElement("span",{className:"text-sm"}, Math.round(hour.temp)+"Â°C"),
              React.createElement("span",{className:"text-xs text-blue-700"}, hour.rain>0 ? hour.rain.toFixed(1)+"mm" : "â€”"),
              React.createElement("span",{className:"text-xs mt-1"}, `${Math.round(hour.windSpeed)} km/h ${getWindArrow(hour.windDir)}`)
            );
          })
        )
      )
    )
  );
}

ReactDOM.createRoot(document.getElementById("root")).render(
  React.createElement(WeatherWidget)
);
</script>
</body>
</html>
