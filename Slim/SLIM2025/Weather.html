<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SLIM 2025 Forecast</title>
<style>
  body { font-family: Arial, sans-serif; background: #222; color: #fff; padding: 20px; }
  h1 { text-align: center; margin-bottom: 30px; }
  .forecast-card { background: rgba(0,0,0,0.7); padding: 15px; margin: 10px 0; border-radius: 10px; display: flex; align-items: center; gap: 15px; }
  .forecast-card img { width: 50px; height: 50px; }
  .forecast-info { display: flex; flex-direction: column; }
</style>
</head>
<body>
<h1>SLIM 2025 - Donegal Forecast</h1>
<div id="forecast-container">Loading forecast...</div>

<script>
async function loadForecast() {
    const container = document.getElementById('forecast-container');
    container.innerHTML = '';

    try {
        const portsalonRes = await fetch('../../forecast_data/portsalon.json');
        const downingsRes = await fetch('../../forecast_data/downings.json');
        const portsalonData = await portsalonRes.json();
        const downingsData = await downingsRes.json();

        const allData = [
            ...portsalonData.map(f => ({...f, location: 'Portsalon'})),
            ...downingsData.map(f => ({...f, location: 'Downings'}))
        ];

        // Filter hours according to your schedule
        function isInTimeRange(f) {
            const dt = new Date(f.time);
            const hour = dt.getUTCHours();
            const day = dt.getUTCDate();
            const loc = f.location;
            if(loc === 'Portsalon' && day === 28) return hour >= 11 && hour <= 19;
            if(loc === 'Downings' && (day === 29 || day === 30)) return hour >= 11 && hour <= 19;
            if(loc === 'Downings' && day === 31) return hour >= 7 && hour <= 15;
            return false;
        }

        const filtered = allData.filter(isInTimeRange);

        if(filtered.length === 0) {
            container.innerHTML = 'No forecast available yet.';
            return;
        }

        // Remove duplicate hours (keep first)
        const uniqueHours = {};
        filtered.forEach(f => {
            const key = f.time.substring(0,13); // YYYY-MM-DDTHH
            if(!uniqueHours[key]) uniqueHours[key] = f;
        });

        const sorted = Object.values(uniqueHours).sort((a,b) => new Date(a.time) - new Date(b.time));

        sorted.forEach(f => {
            const dt = new Date(f.time);
            const dayName = dt.toLocaleDateString('en-GB', { weekday: 'long' });
            const dateStr = dt.toLocaleDateString('en-GB');
            const timeStr = dt.toLocaleTimeString('en-GB', { hour: '2-digit', minute:'2-digit' });

            const card = document.createElement('div');
            card.className = 'forecast-card';
            card.innerHTML = `
                <img src="https://www.met.ie/Open_Data/images/icons/${f.WeatherSymbol3}.png" alt="Weather">
                <div class="forecast-info">
                    <strong>${dayName}, ${dateStr}, ${timeStr} (${f.location})</strong>
                    Temp: ${f.Temperature}°C | Rain: ${f.Rainfall}mm | Wind: ${f.WindSpeed} km/h ${f.WindDirection}°
                </div>
            `;
            container.appendChild(card);
        });

    } catch (err) {
        console.error(err);
        container.innerHTML = 'Error loading forecast.';
    }
}

loadForecast();
</script>
</body>
</html>
