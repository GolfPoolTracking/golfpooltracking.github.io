name: Fetch Met Éireann Forecast

on:
  schedule:
    - cron: '0 * * * *' # every hour on the hour
  workflow_dispatch:    # manual trigger

jobs:
  fetch_forecast:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Install Python dependencies
        run: |
          python3 -m pip install --upgrade pip
          pip install requests xmltodict

      - name: Fetch Met Éireann XML and generate JSON
        run: |
          python3 - <<'PYCODE'
          import requests
          import xmltodict
          import json
          import datetime

          # Configuration for locations and dates
          LOCATIONS = [
              {"name": "Portsalon_28Aug", "lat": 55.266, "lon": -7.633, "date": "2025-08-28"},
              {"name": "Downings_29Aug", "lat": 55.167, "lon": -7.966, "date": "2025-08-29"},
              {"name": "Downings_30Aug", "lat": 55.167, "lon": -7.966, "date": "2025-08-30"},
              {"name": "Downings_31Aug", "lat": 55.167, "lon": -7.966, "date": "2025-08-31"}
          ]

          forecasts_all = []

          for loc in LOCATIONS:
              url = f"http://openaccess.pf.api.met.ie/metno-wdb2ts/locationforecast?lat={loc['lat']};long={loc['lon']}"
              resp = requests.get(url)
              resp.raise_for_status()
              data_xml = resp.text

              data_dict = xmltodict.parse(data_xml)

              product = data_dict.get("weatherdata", {}).get("product", {})
              if not product:
                  continue

              times = product.get("time", [])
              if not isinstance(times, list):
                  times = [times]

              start_dt = datetime.datetime.fromisoformat(loc["date"])
              end_dt   = start_dt + datetime.timedelta(days=1)

              # keep only relevant hours
              for t in times:
                  time_from = t.get("@from")
                  if not time_from:
                      continue
                  dt = datetime.datetime.fromisoformat(time_from)
                  if not (start_dt <= dt < end_dt):
                      continue
                  hour = dt.hour
                  # Only show forecast hours for each day (Portsalon 11-19, Downings 11-19 or 7-15)
                  if loc['name'] == "Portsalon_28Aug" and not (11 <= hour <= 19):
                      continue
                  if loc['name'] in ["Downings_29Aug","Downings_30Aug"] and not (11 <= hour <= 19):
                      continue
                  if loc['name'] == "Downings_31Aug" and not (7 <= hour <= 15):
                      continue

                  loc_data = t.get("location", {})
                  if loc_data is None:
                      continue

                  # Temperature
                  temp = loc_data.get("temperature", {}).get("@value")
                  # Wind
                  wind_dir = loc_data.get("windDirection", {}).get("@deg")
                  wind_speed = loc_data.get("windSpeed", {}).get("@mps")
                  if wind_speed is not None:
                      wind_speed = round(float(wind_speed) * 3.6) # m/s to km/h

                  # Precipitation
                  precip = loc_data.get("precipitation", {}).get("@value")
                  # Symbol
                  symbol = loc_data.get("symbol", {}).get("@number")

                  entry = {
                      "group": loc["name"],
                      "time": time_from,
                      "Temperature": float(temp) if temp else None,
                      "WindDirection": float(wind_dir) if wind_dir else None,
                      "WindSpeed": wind_speed,
                      "Rainfall": float(precip) if precip else None,
                      "WeatherSymbol3": int(symbol) if symbol else None
                  }

                  forecasts_all.append(entry)

          # Output JSON with timestamp
          output = {
              "timestamp": datetime.datetime.utcnow().isoformat() + "Z",
              "forecasts": forecasts_all
          }

          with open("forecast_data/forecast.json", "w") as f:
              json.dump(output, f, indent=2)

          print(f"Wrote {len(forecasts_all)} forecast entries to forecast_data/forecast.json")
          PYCODE

      - name: Commit and push forecast.json
        run: |
          git config --local user.name "github-actions[bot]"
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git add forecast_data/forecast.json
          git commit -m "Update forecast.json [skip ci]" || echo "No changes"
          git push
